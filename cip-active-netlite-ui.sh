#!/usr/bin/env bash
# cip-active-netlite-ui-v9.sh
# Adds:
#   - Sort rows by remaining Time-to-EOL (descending, longest left on top)
#   - Hide -rebase branches by default, unless INCLUDE_REBASE=1
#   - After selection, build and install an Arch package for the chosen CIP kernel with makepkg
#     Supports optional clean-chroot builds with devtools
#     Generates headers package for DKMS users
#     Updates GRUB config or creates a systemd-boot entry by cloning an existing one
#
# Table columns: Branch, Status, Last Commit, First Release (YYYY-MM-DD), EOL (YYYY-MM), Time-to-EOL
#
# References:
#   - PKGBUILD and makepkg usage, functions, and fields. https://wiki.archlinux.org/title/PKGBUILD and https://wiki.archlinux.org/title/Makepkg  (ArchWiki)  [See citations in chat]
#   - Kernel packaging with Arch Build System pattern. https://wiki.archlinux.org/title/Kernel/Arch_build_system  (ArchWiki)
#   - mkinitcpio presets generated by pacman hook on kernel install, images built automatically. https://wiki.archlinux.org/title/Mkinitcpio  (ArchWiki)
#   - Clean chroot builds with devtools. https://wiki.archlinux.org/title/DeveloperWiki:Building_in_a_clean_chroot  (ArchWiki)
#   - GRUB and systemd-boot management. manpages for bootctl and Arch boot process pages  [See citations in chat]
#
# Notes:
#   - Defaults aim for noninteractive success on Arch or EndeavourOS
#   - Safe fallbacks, clear errors, and cleanup are included
#   - You can tweak behavior with ENV vars listed under "Configurable variables"

set -euo pipefail

# --------------------------- Configurable variables ---------------------------
# Build threshold for ACTIVE status
THRESHOLD_DAYS="${THRESHOLD_DAYS:-120}"

# Packaging toggles
USE_CHROOT="${USE_CHROOT:-0}"           # 1 to build in clean chroot with devtools, else 0
AUTO_INSTALL_DEPS="${AUTO_INSTALL_DEPS:-1}"  # 1 to auto-install build deps with pacman
INSTALL_AFTER_BUILD="${INSTALL_AFTER_BUILD:-1}" # 1 to pacman -U after build

# Bootloader actions
UPDATE_GRUB="${UPDATE_GRUB:-auto}"      # auto, 1, or 0
UPDATE_SYSTEMD_BOOT="${UPDATE_SYSTEMD_BOOT:-auto}" # auto, 1, or 0
CREATE_SYSTEMD_BOOT_ENTRY="${CREATE_SYSTEMD_BOOT_ENTRY:-auto}" # auto clone existing entry

# Kernel config seeding
USE_RUNNING_CONFIG="${USE_RUNNING_CONFIG:-1}" # 1 to seed from /proc/config.gz if available
KCONFIG_INTERACTIVE="${KCONFIG_INTERACTIVE:-0}" # 1 to run menuconfig, else olddefconfig
MAKEFLAGS_EXTRA="${MAKEFLAGS_EXTRA:-}"   # extra flags, like "LLVM=1 CC=clang"

# Workspace and retention
WORKDIR="${WORKDIR:-}"                   # default mktemp
KEEP_WORKDIR="${KEEP_WORKDIR:-0}"        # 1 to keep temp dir on exit

# Misc
PKGREL="${PKGREL:-1}"
PKG_OPTIMIZE="${PKG_OPTIMIZE:-1}"        # 1 adds modest ccache/LTO toggles if your makepkg.conf supports them
PKG_DEBUG_SYMBOLS="${PKG_DEBUG_SYMBOLS:-0}" # 1 enables debug package if configured in makepkg.conf

# -----------------------------------------------------------------------------

# Remotes
BASE="https://kernel.googlesource.com/pub/scm/linux/kernel/git/cip/linux-cip"
CLONE_URL="https://git.kernel.org/pub/scm/linux/kernel/git/cip/linux-cip.git"
NOW_EPOCH=$(date +%s)
CIP_WIKI_URL="https://wiki.linuxfoundation.org/civilinfrastructureplatform/start?do=edit"

need_cmd() { command -v "$1" >/dev/null 2>&1; }
curlq() { curl -fsSL "$1"; }  # quiet, fail on HTTP errors
trim() { awk '{$1=$1;print}'; }
die() { printf "Error: %s\n" "$*" >&2; exit 1; }

# Terminal colors (respect NO_COLOR, TERM=dumb, and allow FORCE_COLOR=1)
setup_colors() {
  RED=""; GREEN=""; YELLOW=""; BLUE=""; RESET="";
  if [[ -z "${NO_COLOR:-}" ]] && [[ "${TERM:-}" != "dumb" ]] && { [[ -t 1 ]] || [[ -n "${FORCE_COLOR:-}" ]]; }; then
    if need_cmd tput && tput colors >/dev/null 2>&1; then
      RED="$(tput setaf 1)"; GREEN="$(tput setaf 2)"; YELLOW="$(tput setaf 3)"; BLUE="$(tput setaf 4)"; RESET="$(tput sgr0)";
    else
      RED=$'\033[31m'; GREEN=$'\033[32m'; YELLOW=$'\033[33m'; BLUE=$'\033[34m'; RESET=$'\033[0m';
    fi
  fi
}

# Convert "YYYY-MM" into epoch at last second of that month, use UTC to avoid DST
month_end_epoch() {
  local ym="$1"
  TZ=UTC date -d "${ym}-01 +1 month -1 day 23:59:59" +%s 2>/dev/null || echo 0
}

# Calendar-aware difference in years, months, days between two epochs (start < end)
# Always prints "X yrs Y mos Z days", zeros included, clamped at 0 when end <= start
diff_ymd() {
  local start="$1" end="$2"
  if (( end <= start )); then
    echo "0 yrs 0 mos 0 days"; return
  fi
  local sy sm sd ey em ed
  read -r sy sm sd < <(TZ=UTC date -u -d "@$start" '+%Y %m %d')
  read -r ey em ed < <(TZ=UTC date -u -d "@$end"   '+%Y %m %d')
  local months=$(( (10#$ey - 10#$sy)*12 + (10#$em - 10#$sm) ))
  local anchor
  anchor=$(TZ=UTC date -u -d "$sy-$sm-$sd + ${months} months" +%s)
  if (( anchor > end )); then
    months=$((months - 1))
    anchor=$(TZ=UTC date -u -d "$sy-$sm-$sd + ${months} months" +%s)
  fi
  local years=$(( months / 12 ))
  local mos=$(( months % 12 ))
  local days=$(( (end - anchor)/86400 ))
  (( days < 0 )) && days=0
  printf "%d yrs %d mos %d days\n" "$years" "$mos" "$days"
}

# Build maps:
#   EOL_MAP["6.1"]="2033-08", EOL_MAP["6.1-rt"]="2033-08"
#   FIRST_MAP["6.1"]="2023-07-14", FIRST_MAP["6.1-rt"]="2023-07-16"
declare -A EOL_MAP
declare -A FIRST_MAP
build_eol_map() {
  local src
  if ! src="$(curlq "$CIP_WIKI_URL" 2>/dev/null)"; then
    return 1
  fi
  while IFS='|' read -r _ col_ver _ col_first col_eol _ _; do
    local ver="$(printf '%s' "$col_ver"   | trim)"
    local first="$(printf '%s' "$col_first" | trim)"
    local eol="$(printf '%s' "$col_eol"   | trim)"
    ver="${ver#SLTS v}"
    if [[ "$ver" =~ ^[0-9]+\.[0-9]+(-rt)?$ ]]; then
      [[ "$eol"   =~ ^[0-9]{4}-[0-9]{2}$        ]] && EOL_MAP["$ver"]="$eol"
      [[ "$first" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]] && FIRST_MAP["$ver"]="$first"
    fi
  done < <(printf '%s\n' "$src" | awk -F'[|]' '/[|][[:space:]]*SLTS v[0-9]+\.[0-9]+/ {print}')
}

# Map a branch name to EOL key: linux-6.1.y-cip[-rt|-rebase] -> "6.1" or "6.1-rt"
branch_to_eol_key() {
  local br="$1" ver rest
  if [[ "$br" =~ linux-([0-9]+\.[0-9]+)\.y-cip(.*) ]]; then
    ver="${BASH_REMATCH[1]}"
    rest="${BASH_REMATCH[2]}"
    if [[ "$rest" == *-rt* ]]; then
      printf '%s-rt\n' "$ver"
    else
      printf '%s\n' "$ver"
    fi
  fi
}

# Discover branches from +refs, optionally exclude *-rebase
REFS_HTML="$(curlq "$BASE/+refs")"
mapfile -t BRANCHES_ALL < <(printf '%s\n' "$REFS_HTML" \
  | grep -oE 'linux-[0-9]+\.[0-9]+\.y-cip(-rt|-rebase)?' \
  | sort -Vu)

if ((${#BRANCHES_ALL[@]}==0)); then
  echo "No CIP branches found on +refs"
  exit 1
fi

BRANCHES=()
if [[ -n "${INCLUDE_REBASE:-}" ]]; then
  BRANCHES=("${BRANCHES_ALL[@]}")
else
  for b in "${BRANCHES_ALL[@]}"; do
    [[ "$b" == *-rebase ]] && continue
    BRANCHES+=("$b")
  done
fi

# Read head in TEXT mode, base64-decode, parse committer epoch
branch_head_epoch() {
  local br="$1" b64 epoch
  if ! b64="$(curlq "$BASE/+/refs/heads/$br?format=TEXT" 2>/dev/null)"; then
    echo 0; return
  fi
  epoch="$(printf '%s' "$b64" | base64 -d 2>/dev/null \
           | awk '/^committer /{print $(NF-1); exit}')"
  [[ "$epoch" =~ ^[0-9]+$ ]] && printf '%s\n' "$epoch" || echo 0
}

# Pretty "N days ago" text
fmt_days_ago() {
  local d="$1"
  if   (( d <= 0 )); then echo "today"
  elif (( d == 1 )); then echo "1 day ago"
  else                   echo "$d days ago"
  fi
}

# Build maps once
build_eol_map || true

# Set up colors
setup_colors

# Assemble rows, sort by EOL descending
declare -a BODY_SORTABLE=()
declare -a ACTIVE_SORTABLE=()
HEADER=$'Branch\tStatus\tLast Commit\tFirst Release\tEOL\tTime-to-EOL'

ACTIVE=()
NOW_EPOCH=$(date +%s)
for br in "${BRANCHES[@]}"; do
  epoch="$(branch_head_epoch "$br")"
  status="UNKNOWN"
  age_str="-"
  if (( epoch > 0 )); then
    age_days=$(( (NOW_EPOCH - epoch)/86400 ))
    (( age_days < 0 )) && age_days=0
    status="STALE"
    (( NOW_EPOCH - epoch < THRESHOLD_DAYS*86400 )) && status="ACTIVE"
    age_str="$(fmt_days_ago "$age_days")"
    [[ "$status" == "ACTIVE" ]] && ACTIVE+=("$br")
  fi
  key="$(branch_to_eol_key "$br")"
  first_rel="${FIRST_MAP[$key]:-UNKNOWN}"
  eol="${EOL_MAP[$key]:-UNKNOWN}"
  eol_epoch=-1
  tte="-"
  if [[ "$eol" != "UNKNOWN" ]]; then
    eol_epoch="$(month_end_epoch "$eol")"
    if (( eol_epoch > 0 )); then
      tte="$(diff_ymd "$NOW_EPOCH" "$eol_epoch")"
    else
      eol_epoch=-1
    fi
  fi
  row="$(printf "%s\t%s\t%s\t%s\t%s\t%s" "$br" "$status" "$age_str" "$first_rel" "$eol" "$tte")"
  BODY_SORTABLE+=( "$(printf "%s\t%s" "$eol_epoch" "$row")" )
  if [[ "$status" == "ACTIVE" ]]; then
    ACTIVE_SORTABLE+=( "$(printf "%s\t%s" "$eol_epoch" "$br")" )
  fi
done

sorted_body="$(
  printf "%s\n" "${BODY_SORTABLE[@]}" \
  | sort -t $'\t' -k1,1nr -k2,2 \
  | cut -f2-
)"

out="$HEADER"$'\n'"$sorted_body"
if need_cmd column; then
  out="$(printf "%s\n" "$out" | column -t -s $'\t')"
else
  out="$(printf "%s\n" "$out" | sed $'s/\t/  /g')"
fi
if [[ -n "${GREEN}${RED}${RESET}" ]]; then
  out="$(printf "%s\n" "$out" | sed -E "1! s/ACTIVE/${GREEN}&${RESET}/g; 1! s/STALE/${RED}&${RESET}/g")"
fi
printf "%s\n" "$out"

if ((${#ACTIVE[@]}==0)); then
  echo
  echo "No ACTIVE branches under the current threshold ($THRESHOLD_DAYS days)."
  exit 0
fi

echo
echo "Pick an ACTIVE branch:"
choice=""
ACTIVE_LIST_SORTED="$(
  printf "%s\n" "${ACTIVE_SORTABLE[@]}" \
  | sort -t $'\t' -k1,1nr -k2,2 \
  | cut -f2-
)"
if need_cmd fzf; then
  choice="$(printf "%s\n" "$ACTIVE_LIST_SORTED" | fzf --prompt="SLTS> " --height=10 --reverse)" || true
else
  PS3="Select branch> "
  ACTIVE_ARR=( $(printf "%s\n" "$ACTIVE_LIST_SORTED") )
  select br in "${ACTIVE_ARR[@]}"; do choice="$br"; break; done
fi
[[ -n "${choice:-}" ]] && echo "You selected: $choice"

# ---------- Packaging helpers ----------
is_arch_like() { need_cmd pacman; }
ensure_not_root_for_makepkg() { if (( EUID == 0 )); then die "Do not run makepkg as root. Use a normal user with sudo for pacman."; fi; }
sudo_or_die() { if ! need_cmd sudo; then die "sudo is required for installing deps and packages"; fi; }

pacman_install() {
  sudo_or_die
  local pkgs=("$@")
  sudo pacman -Sy --needed --noconfirm "${pkgs[@]}"
}

check_and_install_build_deps() {
  echo "Checking build dependencies..."
  local base=("base-devel" "git")
  local kernel_build=("bc" "kmod" "libelf" "pahole" "python" "cpio" "perl" "tar" "xz" "flex" "bison" "openssl" "zstd")
  if (( AUTO_INSTALL_DEPS )); then
    pacman_install "${base[@]}" "${kernel_build[@]}"
  else
    for p in "${base[@]}" "${kernel_build[@]}"; do
      pacman -Qi "$p" >/dev/null 2>&1 || echo "Missing: $p"
    done
  fi
}

detect_bootloader() {
  # Sets BOOTLOADER=grub or systemd-boot or unknown
  BOOTLOADER="unknown"
  if need_cmd bootctl && bootctl status >/dev/null 2>&1; then
    BOOTLOADER="systemd-boot"
  fi
  if need_cmd grub-mkconfig || [[ -d /boot/grub ]]; then
    # prefer grub if both are present and UPDATE_GRUB=1
    [[ "$BOOTLOADER" == "unknown" ]] && BOOTLOADER="grub"
  fi
  echo "Detected bootloader: $BOOTLOADER"
}

boot_path_systemd_boot() {
  # Print the correct path for loader entries, prefers Extended Boot Loader partition
  if need_cmd bootctl; then
    local p
    if p="$(bootctl --print-boot-path 2>/dev/null)"; then
      printf "%s\n" "$p"
      return 0
    fi
  fi
  # Fallbacks
  for d in /boot /efi /boot/efi; do
    [[ -d "$d/loader/entries" ]] && { printf "%s\n" "$d"; return 0; }
  done
  return 1
}

clone_existing_systemd_entry() {
  # Clone an existing entry to preserve root options, then point to our kernel
  local pkgbase="$1"
  local kimg="vmlinuz-${pkgbase}"
  local initrd="initramfs-${pkgbase}.img"
  local bootp
  bootp="$(boot_path_systemd_boot)" || return 1
  local entries="$bootp/loader/entries"
  [[ -d "$entries" ]] || return 1

  # pick the first .conf
  local src
  src="$(ls -1 "$entries"/*.conf 2>/dev/null | head -n1 || true)"
  [[ -n "$src" ]] || return 1

  local dest="$entries/${pkgbase}.conf"
  cp -n "$src" "$dest" || return 1

  # Replace linux/initrd lines to point to our images in /boot
  # If ESP is not /boot, the lines still commonly reference /vmlinuz-* and /initramfs-*.img
  sed -i -E \
    -e "s|^linux .*|linux /$kimg|g" \
    -e "s|^initrd .*|initrd /$initrd|g" \
    "$dest"
  echo "Created systemd-boot entry: $dest"
  return 0
}

maybe_update_bootloader() {
  detect_bootloader
  case "$BOOTLOADER" in
    grub)
      local do_update="$UPDATE_GRUB"
      [[ "$do_update" == "auto" ]] && do_update=1
      if (( do_update )) && need_cmd grub-mkconfig; then
        echo "Updating GRUB menu..."
        sudo grub-mkconfig -o /boot/grub/grub.cfg || echo "GRUB update failed, check your setup."
      else
        echo "Skipped GRUB update."
      fi
      ;;
    systemd-boot)
      local do_update="$UPDATE_SYSTEMD_BOOT"
      [[ "$do_update" == "auto" ]] && do_update=1
      if (( do_update )); then
        # Try creating a cloned entry if requested
        local do_clone="$CREATE_SYSTEMD_BOOT_ENTRY"
        [[ "$do_clone" == "auto" ]] && do_clone=1
        (( do_clone )) && clone_existing_systemd_entry "$1" || true
        if need_cmd bootctl; then
          echo "Updating systemd-boot..."
          sudo bootctl update || echo "systemd-boot update failed, check your setup."
        fi
      else
        echo "Skipped systemd-boot update."
      fi
      ;;
    *)
      echo "Bootloader not detected. You may need to add an entry manually."
      ;;
  esac
}

gen_pkgbuild() {
  local pkgdir="$1" choice="$2" pkgbase="$3" pkgrel="$4"
  local srcurl="git+${CLONE_URL}#branch=${choice}"
  cat >"$pkgdir/PKGBUILD" <<'EOF'
# shellcheck disable=SC2034
pkgbase=
pkgname=()
pkgver=0
pkgrel=
arch=('x86_64')
url='https://wiki.linuxfoundation.org/civilinfrastructureplatform'
license=('GPL2')
makedepends=('git' 'bc' 'kmod' 'libelf' 'pahole' 'python' 'cpio' 'perl' 'tar' 'xz' 'flex' 'bison' 'openssl' 'zstd')
options=('!strip')  # do not strip kernel image
source=()
sha256sums=('SKIP')

# helper to run make with consistent flags
_kmake() {
  make -s "${MAKEFLAGS}" ${MAKEFLAGS_EXTRA} "$@"
}

pkgver() {
  cd linux-cip
  # prefer tags if any, else revcount + short hash
  local v
  v="$(git describe --tags --match 'v*' --long --dirty 2>/dev/null || true)"
  if [[ -n "$v" ]]; then
    v="${v#v}"
    v="${v//-/.}"
    printf "%s\n" "$v"
  else
    printf "r%s.%s\n" "$(git rev-list --count HEAD)" "$(git rev-parse --short HEAD)"
  fi
}

prepare() {
  cd linux-cip
  # Seed config
  if [[ -f "${srcdir}/config.seed" ]]; then
    cp "${srcdir}/config.seed" .config
    _kmake olddefconfig
  else
    _kmake x86_64_defconfig
    _kmake olddefconfig
  fi
  # Optional interactive config
  if [[ "${KCONFIG_INTERACTIVE:-0}" == "1" ]]; then
    _kmake menuconfig
  fi
}

build() {
  cd linux-cip
  _kmake prepare
  _kmake bzImage modules
}

_package_common_install() {
  local krel
  krel="$(_kmake -C linux-cip kernelrelease)"
  install -Dm644 linux-cip/System.map    "${pkgdir}/boot/System.map-${pkgbase}"
  install -Dm644 linux-cip/.config       "${pkgdir}/boot/config-${pkgbase}"
  install -Dm644 linux-cip/arch/x86/boot/bzImage "${pkgdir}/boot/vmlinuz-${pkgbase}"
  # modules
  _kmake -C linux-cip INSTALL_MOD_PATH="${pkgdir}" modules_install
  # mark pkgbase for mkinitcpio preset generation
  echo "${pkgbase}" > "${pkgdir}/usr/lib/modules/${krel}/pkgbase"
}

package() {
  pkgdesc="Linux kernel for CIP ${pkgbase}, built from ${source[0]}"
  depends=('coreutils' 'linux-firmware' 'kmod' 'mkinitcpio')
  provides=()
  conflicts=()
  cd "${srcdir}"
  _package_common_install
}

package_headers() {
  pkgdesc="Headers and build files for ${pkgbase}"
  depends=('perl')
  cd "${srcdir}"
  local krel
  krel="$(make -s -C linux-cip kernelrelease)"
  local hdrdir="${pkgdir}/usr/lib/modules/${krel}/build"
  install -dm755 "${hdrdir}"
  # Copy sanitized tree for module builds. Heavy but robust.
  rsync -a --delete \
    --exclude='.git' --exclude='*.o' --exclude='*.cmd' --exclude='.tmp*' \
    --exclude='Module.markers' --exclude='modules.order' \
    linux-cip/ "${hdrdir}/"
  # Ensure required generated files exist
  install -Dm644 linux-cip/Module.symvers "${hdrdir}/Module.symvers" || true
  install -Dm644 linux-cip/.config       "${hdrdir}/.config"
  # Headers for userspace
  make -s -C linux-cip INSTALL_HDR_PATH="${pkgdir}/usr" headers_install
  # Symlink build and source as expected by DKMS
  ln -sfn "/usr/lib/modules/${krel}/build" "${pkgdir}/usr/lib/modules/${krel}/source"
}
EOF

  # now patch in dynamic fields
  sed -i \
    -e "s|^pkgbase=.*$|pkgbase=${pkgbase}|" \
    -e "s|^pkgname=.*$|pkgname=('${pkgbase}' '${pkgbase}-headers')|" \
    -e "s|^pkgrel=.*$|pkgrel=${pkgrel}|" \
    -e "s|^source=.*$|source=('${srcurl}' 'config.seed')|" \
    "$pkgdir/PKGBUILD"
}

seed_config_if_available() {
  local out="$1/config.seed"
  if (( USE_RUNNING_CONFIG )) && [[ -r /proc/config.gz ]]; then
    echo "Seeding kernel config from /proc/config.gz"
    zcat /proc/config.gz > "$out" || true
  else
    # fallback minimal seed
    printf "# minimal seed, PKGBUILD will do x86_64_defconfig\n" > "$out"
  fi
}

build_with_makepkg_or_chroot() {
  local dir="$1"
  pushd "$dir" >/dev/null
  if (( USE_CHROOT )) && need_cmd extra-x86_64-build; then
    echo "Building in clean chroot with extra-x86_64-build..."
    extra-x86_64-build -c || extra-x86_64-build
  else
    echo "Building locally with makepkg..."
    makepkg -s --noconfirm --clean --cleanbuild
  fi
  popd >/dev/null
}

install_built_packages() {
  local dir="$1"
  shopt -s nullglob
  local pkgs=("$dir"/*.pkg.tar.*)
  (( ${#pkgs[@]} > 0 )) || die "No packages produced"
  echo "Installing packages: ${pkgs[*]}"
  pacman_install "${pkgs[@]}"
}

cleanup_workdir() {
  local dir="$1"
  if (( KEEP_WORKDIR )); then
    echo "Keeping workspace at: $dir"
  else
    rm -rf "$dir"
  fi
}

# main packaging entry
package_selected_branch() {
  local choice="$1"
  is_arch_like || die "This flow is for Arch-like systems with pacman."

  ensure_not_root_for_makepkg
  (( AUTO_INSTALL_DEPS )) && check_and_install_build_deps

  # Derive version and pkgbase
  local ver=""; local is_rt=0
  if [[ "$choice" =~ linux-([0-9]+\.[0-9]+)\.y-cip(.*) ]]; then
    ver="${BASH_REMATCH[1]}"
    [[ "${BASH_REMATCH[2]}" == *-rt* ]] && is_rt=1
  else
    die "Could not derive version from branch: $choice"
  fi
  local pkgbase
  if (( is_rt )); then
    pkgbase="linux-cip-rt-${ver}"
  else
    pkgbase="linux-cip-${ver}"
  fi
  echo "Packaging as pkgbase=${pkgbase}"

  local tmp="${WORKDIR:-}"
  [[ -z "$tmp" ]] && tmp="$(mktemp -d -t cip-pkg-XXXXXX)"
  echo "Workspace: $tmp"
  trap 'echo "Build failed. Leaving workspace: '"$tmp"'"; exit 1' ERR INT TERM

  # Write PKGBUILD and seed config
  gen_pkgbuild "$tmp" "$choice" "$pkgbase" "$PKGREL"
  seed_config_if_available "$tmp"

  # Build
  build_with_makepkg_or_chroot "$tmp"

  # Install
  if (( INSTALL_AFTER_BUILD )); then
    install_built_packages "$tmp"
    # mkinitcpio preset creation and image generation are handled by pacman hooks
    # per ArchWiki mkinitcpio docs
    maybe_update_bootloader "$pkgbase"
  else
    echo "INSTALL_AFTER_BUILD=0, skipping installation."
  fi

  trap - ERR INT TERM
  cleanup_workdir "$tmp"
  echo "Done."
}

# --------------------- end helpers, begin action -----------------------

if [[ -n "${choice:-}" ]]; then
  # Instead of cloning, we package and install
  package_selected_branch "$choice"
fi
